using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using BestHTTP.SocketIO;
using TMPro;
using UnityEngine.Serialization;
using Object = System.Object;
using UnityEngine.UI;
using Random = System.Random;
using UnityEngine.SceneManagement;


public class UnitySocketClient : MonoBehaviour{
    public GameObject particleSystem;
    //Socket
    private SocketManager _manager;
    private Socket _unityClientSocket;
    public string connectionAddress = "https://elsland.herokuapp.com/socket.io/" ;
    //Intro Scene Variables
    private int _numberOfConnections = 0;
    public TextMeshProUGUI connectionNumberText;
    public TextMeshProUGUI[] connectionIPs;
    public TextMeshProUGUI[] interactionTexts;
    public String targetConnectionNumber;
    private int _numberOfBlocksErased;
    private int _targetConnectionNumber;
    private List<GameObject> _blocksList;
    //To store all the cut points generated by the cut manager
    //Cut Scene Variables
    public double[] cutPoints;
    public float[] blockCutPoints;
    public float[] blockCutPercents;
    private List<Pair2D> _userCutPoints = new List<Pair2D>();
    public Color cutLineColor;
    public Material cutMaterial;
    private bool _keyPressed;
    private bool _sendKeyPressed;
    public float[] cutBound;
    public float xTrainOffset;
    public float yTrainOffset;
    public int totalBlocks;
    public int totalCut; // Should Match with cut manager
    public int cutTarget;
    private bool _alreadyCut;
    
    
    
    //Light Scene Variables
    private List<GameObject> _lightsToTurnOn = new List<GameObject>();
    private List<GameObject> _lightsToDim = new List<GameObject>();
    private Dictionary<string, int> _socketIDLightIndex = new Dictionary<string, int>();
    private int _lightOnConnectionNumbers;
    private int _numOfLightsOnPerConnection;
    private int _numOfLightsDimPerConnection;
    private int _currentDimIndex; 
    
    
    void Awake(){
        _manager = new SocketManager(new Uri(connectionAddress));
        _unityClientSocket = _manager.GetSocket("/unity-client");
        DontDestroyOnLoad(this.gameObject);
    }

    void Start(){
        _alreadyCut = false;
        _sendKeyPressed = false;
        _targetConnectionNumber = int.Parse(targetConnectionNumber);
//        interactionText.enabled = false;
        foreach (var introTexts in interactionTexts){
            introTexts.enabled = false;
        }

        _currentDimIndex = 0;
        _keyPressed = false;
        _unityClientSocket.On("connect", OnConnected);
        _unityClientSocket.On("intro_client_connect", OnIntroClientConnect);
        _unityClientSocket.On("intro_client_disconnect", OnIntroClientDisconnect);
        _unityClientSocket.On("start_erase_blocks", OnStartEraseBlock);
        _unityClientSocket.On("start_batch_erase_blocks", OnIntroBlockBatchErase);
        _unityClientSocket.On("intro_block_erased", OnIntroBlockErased);
        _unityClientSocket.On("num_of_light_on_connections", OnConnectionNumbers);
        _unityClientSocket.On("light_on", OnLightOn);
        _unityClientSocket.On("light_dim", onLightDim);
        _unityClientSocket.On("cut", onCut);
        _unityClientSocket.On("batch_draw_cut_lines", onBatchDrawCutline);
        _unityClientSocket.On("train_cut", onTrainCut);

//        GameObject[] lightsToUse = GameObject.FindGameObjectsWithTag("light_on");
//        foreach (var k in lightsToUse)
//        {
//            _lightsToTurnOn.Add(k);
//        }
//
//        GameObject[] lightsToDim = GameObject.FindGameObjectsWithTag("light_dim");
//        foreach (var j in lightsToDim)
//        {
//            _lightsToDim.Add(j);
//        }

    }
    // Update is called once per frame
    void Update(){
        //Simple Test before implementing event
        if (Input.GetKey(KeyCode.K)){
            GameObject.Find("MainTimeline").GetComponent<FallingTimeManager>().ResumeTimeline();
        }

        if (Input.GetKey(KeyCode.S) && !_sendKeyPressed){
            SendCut();
            _keyPressed = true;
            Debug.Log("Send Cut Event");
        }
        
        if (Input.GetKey(KeyCode.V) && !_keyPressed){
            _keyPressed = true;
            foreach (var cutPair in _userCutPoints){
                List<Slice2D> sliceResult = Slicer2D.LinearSliceAll(cutPair, Slice2DLayer.Create());
                foreach (var slice in sliceResult){
                    List<GameObject> slicedGameObjects = slice.GetGameObjects();
                    foreach (var sg in slicedGameObjects){
                        sg.GetComponent<Rigidbody2D>().AddForce(UnityEngine.Random.insideUnitCircle, ForceMode2D.Impulse);
                    }
                }
            }
            GameObject[] cutLines = GameObject.FindGameObjectsWithTag("cut_line");
            foreach (var cutLine in cutLines){
                Destroy(cutLine);
            }
        }

//        if (_userCutPoints.Count == cutTarget && !_alreadyCut){
//            Debug.Log("wtf why it sends all the time");
//            SendCutFall();
//            Cut();
//            GameObject.Find("MainTimeline").GetComponent<FallingTimeManager>().ResumeTimeline();
//            _alreadyCut = true;
//        } 
    }

    public void Cut(){
        foreach (var cutPair in _userCutPoints){
            List<Slice2D> sliceResult = Slicer2D.LinearSliceAll(cutPair, Slice2DLayer.Create());
            foreach (var slice in sliceResult){
                List<GameObject> slicedGameObjects = slice.GetGameObjects();
                foreach (var sg in slicedGameObjects){
                    sg.GetComponent<Rigidbody2D>().AddForce(UnityEngine.Random.insideUnitCircle * 20, ForceMode2D.Impulse);
                    sg.AddComponent<SliceMoveOut>();
                }
            }
        }
        GameObject[] cutLines = GameObject.FindGameObjectsWithTag("cut_line");
        foreach (var cutLine in cutLines){
            Destroy(cutLine);
        }
    } 
    

    void OnConnected(Socket socket, Packet packet, params object[] args){
        Debug.Log("Connected to the server");
    }

    void OnIntroClientConnect(Socket socket, Packet packet, params object[] args){
//        _numberOfConnections++;
//        String strConnectionNumber = _numberOfConnections.ToString();
//        String result = strConnectionNumber + "/" + targetConnectionNumber;
//        connectionNumberText.text = result;
        if (_numberOfConnections == _targetConnectionNumber){
            foreach (var ip in connectionIPs){
                ip.enabled = false;
            }
            foreach (var iTexts in interactionTexts){
                iTexts.enabled = true;
            }
            connectionNumberText.enabled = false;
            GameObject blockManager = GameObject.Find("BlockManager");
            _blocksList = blockManager.GetComponent<IntroBlocksManager>().introBlocks;
            particleSystem.SetActive(true);
            StartCoroutine(DisableInteractionText());
        }
    }
    
    
    void OnStartEraseBlock(Socket socket, Packet packet, params object[] args){
        foreach (var ip in connectionIPs){
            ip.enabled = false;
        }
        foreach (var iTexts in interactionTexts){
            iTexts.enabled = true;
        }
        connectionNumberText.enabled = false;
        GameObject blockManager = GameObject.Find("BlockManager");
        _blocksList = blockManager.GetComponent<IntroBlocksManager>().introBlocks;
        StartCoroutine(waitForParticle());
        StartCoroutine(DisableInteractionText());
    }

    IEnumerator waitForParticle(){
        yield return new WaitForSeconds(6);
        particleSystem.SetActive(true);
    }


    IEnumerator DisableParticle(){
        yield return new WaitForSeconds(2);
        particleSystem.SetActive(false);
    }
    
    IEnumerator DisableInteractionText(){
        yield return new WaitForSeconds(10);
//        interactionText.enabled = false;
        foreach (var iTexts in interactionTexts){
            iTexts.enabled = false;
        }
        //Sending Information to the server to show the interaction screen   
        //Show The particle system below, when particle is showing, send info to server 
        SendIntro();
        GameObject.Find("Main Camera").GetComponent<AudioSource>().Play();
//        StartCoroutine(DisableParticle());
        //Particle also should have a timespan  
    }
    
    void OnIntroClientDisconnect(Socket socket, Packet packet, params object[] args){
        _numberOfConnections--;
        if (_numberOfConnections < 0){
            _numberOfConnections = 0;
        }
//        String strConnectionNumber = _numberOfConnections.ToString();
//        String result = strConnectionNumber + "/" + targetConnectionNumber;
//        connectionNumberText.text = result;
    }
    
    IEnumerator EraseBlockWithTimeInterval(){
        particleSystem.SetActive(false);
        while (true){
            EraseScreenBlock();
            int blocksNumber = _blocksList.Count;
            if (blocksNumber <= 0){
                StartCoroutine(ChangeSceneAsync());
                break;
            }
            yield return new WaitForSeconds(0.03F);
        }
    }

    void OnIntroBlockBatchErase(Socket socket, Packet packet, params object[] args){
        Debug.Log("Start Batch Erase");
        StartCoroutine(EraseBlockWithTimeInterval());
    }

    void OnIntroBlockErased(Socket socket, Packet packet, params object[] args){
        Debug.Log("Got Erase Block Message");
        EraseScreenBlock();
        _numberOfBlocksErased++;
//        if (_numberOfBlocksErased == _targetConnectionNumber){
//            Debug.Log("Erased Enough Blocks");
//            StartCoroutine(EraseBlockWithTimeInterval());
//        }
    }


    private void EraseScreenBlock(){
        int blocksNumber = _blocksList.Count;
        if (blocksNumber > 0){
            int removeIndex = UnityEngine.Random.Range(0, blocksNumber);
            GameObject blockToRemove = _blocksList[removeIndex];
            _blocksList.RemoveAt(removeIndex);
            Destroy(blockToRemove);
        }
    }

    IEnumerator ChangeScene(){
        yield return new WaitForSeconds(3);
        SceneManager.LoadScene("00Reality");
    }
    
    IEnumerator ChangeSceneAsync(){
        yield return new WaitForSeconds(3);
        AsyncOperation async = SceneManager.LoadSceneAsync("00Reality");
        async.allowSceneActivation = true;
        while(!async.isDone){
            yield return null;
        }
    }
    
    void OnConnectionNumbers(Socket socket, Packet packet, params object[] args){
        _lightOnConnectionNumbers = int.Parse(args[0].ToString());
        _numOfLightsOnPerConnection = _lightsToTurnOn.Count/_lightOnConnectionNumbers;
        _numOfLightsDimPerConnection = _lightsToDim.Count / _lightOnConnectionNumbers; 
        Debug.Log(_lightOnConnectionNumbers);
    }

    void OnLightOn(Socket socket, Packet packet, params object[] args){
        if (_lightsToTurnOn.Count >= _numOfLightsOnPerConnection){
            for (int i = 0; i < _numOfLightsOnPerConnection; i++){
                GameObject lightToUse = _lightsToTurnOn[0];
                lightToUse.GetComponent<Light>().enabled = true;
                _lightsToTurnOn.Remove(lightToUse);
            }
        }
    }

    void onLightDim(Socket socket, Packet packet, params object[] args){
        string socket_id = args[0].ToString();
        float intensity = float.Parse(args[1].ToString());
        if (!_socketIDLightIndex.ContainsKey(socket_id)){
            _socketIDLightIndex[socket_id] = _currentDimIndex;
            for (int i = _currentDimIndex; i < _currentDimIndex + _numOfLightsDimPerConnection; i++){
                _lightsToDim[i].GetComponent<Light>().intensity = intensity;
            }
            _currentDimIndex += _numOfLightsDimPerConnection;
        }
        else{
            int lightIndex = _socketIDLightIndex[socket_id];
            for (int i = lightIndex; i < lightIndex + _numOfLightsDimPerConnection; i++){
                _lightsToDim[i].GetComponent<Light>().intensity = intensity;
            }
        }
    }

    void onCut(Socket socket, Packet packet, params object[] args){
        Debug.Log("client finished cutting");
        String strCutIndex = args[0].ToString();
        int cutIndex = int.Parse(strCutIndex);
        Debug.Log(cutIndex);
        Vector2D pointA = new Vector2D(blockCutPoints[cutIndex*4], blockCutPoints[cutIndex*4+1]);
        Vector2D pointB = new Vector2D(blockCutPoints[cutIndex*4+2], blockCutPoints[cutIndex*4+3]);
        DrawLine(pointA, pointB, cutLineColor);
        Pair2D cutPair = new Pair2D(pointA, pointB);
        _userCutPoints.Add(cutPair);
    }

    void onTrainCut(Socket socket, Packet packet, params object[] args){
        SendCutFall();
        Cut();
        GameObject.Find("MainTimeline").GetComponent<FallingTimeManager>().ResumeTimeline();
        _alreadyCut = true;
    }
    

    void onBatchDrawCutline(Socket socket, Packet packet, params object[] args){
        Debug.Log("Start Batch Drawlines");
        StartCoroutine(BatchDrawLineWithInterval());
    }
    
    IEnumerator BatchDrawLineWithInterval(){
        int[] drawIndex = new int[totalCut];
        for (int i = 0; i < totalCut; i++){
            drawIndex[i] = i;
        }
        for (int i = 0; i < drawIndex.Length; i++) {
            int rnd = UnityEngine.Random.Range(0, drawIndex.Length);
            int temp = drawIndex[rnd];
            drawIndex[rnd] = drawIndex[i];
            drawIndex[i] = temp;
        }
        int drawLineProgress = 0;
        while (true){
            if (drawLineProgress < totalCut){
                int drawLineIndex = drawIndex[drawLineProgress];
                Vector2D pointA = new Vector2D(blockCutPoints[drawLineIndex*4], blockCutPoints[drawLineIndex*4+1]);
                Vector2D pointB = new Vector2D(blockCutPoints[drawLineIndex*4+2], blockCutPoints[drawLineIndex*4+3]);
                DrawLine(pointA, pointB, cutLineColor);
                Pair2D cutPair = new Pair2D(pointA, pointB);
                _userCutPoints.Add(cutPair);
                drawLineProgress += 1;
            }
            else{
                break;
            }
            yield return new WaitForSeconds(0.09F);
        }
    }
    
    
    public void SendLightOn(){
        _unityClientSocket.Emit("start_light_on");
    }

    public void SendLightDim(){
        _unityClientSocket.Emit("start_light_dim");
    }

    public void SendCutFall(){
        _unityClientSocket.Emit("start_cut_fall");
    }
    
    public void SendCut(){
        Debug.Log("Send Cut Scene Event");
        Dictionary<string, object> cutData = new Dictionary<string, object>();
        cutData.Add("data", blockCutPercents);
        cutData.Add("cutBound", cutBound);
        cutData.Add("xOffSet", xTrainOffset);
        cutData.Add("yOffSet", yTrainOffset);
        cutData.Add("segmentNumber", totalBlocks);
        _unityClientSocket.Emit("start_cut", cutData);
    }

    private void SendIntro(){
        Debug.Log("Send Intro Scene Event");
        _unityClientSocket.Emit("start_intro_interaction");
    }
    
    private void DrawLine(Vector2D start2D, Vector2D end2D, Color color){
//        Vector3 start = new Vector3((float) start2D.x , (float) start2D.y , (float) -120.9);
//        Vector3 end = new Vector3((float)end2D.x , (float)end2D.y, (float)-120.9);
        Vector3 start = new Vector3((float) start2D.x , (float) start2D.y , (float) -0.9);
        Vector3 end = new Vector3((float)end2D.x , (float)end2D.y, (float)-0.9);
//        start = start * 1.2f;
//        end = end * 1.2f;
        GameObject myLine = new GameObject();
        myLine.tag = "cut_line";
        myLine.transform.position = start;
        myLine.AddComponent<LineRenderer>();
        LineRenderer lr = myLine.GetComponent<LineRenderer>();
        lr.material = cutMaterial;
//        lr.widthMultiplier = 0.8f;
        lr.widthMultiplier = 0.08f;
        lr.SetPosition(0, start);
        lr.SetPosition(1, end);
    }
    
}
